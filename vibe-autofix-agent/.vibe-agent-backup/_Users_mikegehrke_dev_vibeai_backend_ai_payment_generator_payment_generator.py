"""
Payment Generator - Generiert produktionsfÃ¤higen Payment-Code
UnterstÃ¼tzt: Stripe, PayPal, Subscriptions, One-Time Payments
"""

from dataclasses import dataclass
from enum import Enum
from typing import Any, Dict, List, Optional


class PaymentProvider(str, Enum):
    """Payment Provider"""

    STRIPE = "stripe"
    PAYPAL = "paypal"
    BOTH = "both"


class PricingModel(str, Enum):
    """Pricing Models"""

    ONE_TIME = "one_time"
    SUBSCRIPTION = "subscription"
    USAGE_BASED = "usage_based"
    TIERED = "tiered"


class Framework(str, Enum):
    """UnterstÃ¼tzte Frameworks"""

    FASTAPI = "fastapi"
    DJANGO = "django"
    FLASK = "flask"
    EXPRESS = "express"
    NEXTJS = "nextjs"
    REACT = "react"
    FLUTTER = "flutter"
    REACT_NATIVE = "react_native"


@dataclass
class PaymentConfig:
    """Payment Konfiguration"""

    provider: PaymentProvider
    pricing_model: PricingModel
    currency: str = "usd"
    amount: Optional[float] = None
    products: List[Dict[str, Any]] = None
    subscription_interval: str = "month"  # month, year
    trial_days: int = 0
    success_url: str = "https://yourapp.com/success"
    cancel_url: str = "https://yourapp.com/cancel"
    webhook_secret: Optional[str] = None


@dataclass
class GeneratedCode:
    """Generierter Payment-Code"""

    backend_code: str
    frontend_code: str
    webhook_code: str
    env_variables: Dict[str, str]
    installation_commands: List[str]
    setup_instructions: str


class PaymentGenerator:
    """
    Haupt-Engine fÃ¼r Payment Code-Generierung
    """

    def __init__(self):
        pass

    def generate_payment_system(
        self,
        config: PaymentConfig,
        backend_framework: Framework,
        frontend_framework: Optional[Framework] = None,
    ) -> GeneratedCode:
        """
        Generiere komplettes Payment-System

        Args:
            config: Payment Konfiguration
            backend_framework: Backend Framework
            frontend_framework: Frontend Framework (optional)

        Returns:
            GeneratedCode mit Backend, Frontend, Webhooks
        """
        # Generate backend code
        backend_code = self._generate_backend(config, backend_framework)

        # Generate frontend code
        frontend_code = ""
        if frontend_framework:
            frontend_code = self._generate_frontend(config, frontend_framework)

        # Generate webhook handlers
        webhook_code = self._generate_webhooks(config, backend_framework)

        # Environment variables
        env_vars = self._generate_env_variables(config)

        # Installation commands
        install_commands = self._generate_install_commands(config, backend_framework, frontend_framework)

        # Setup instructions
        setup_instructions = self._generate_setup_instructions(config)

        return GeneratedCode(
            backend_code=backend_code,
            frontend_code=frontend_code,
            webhook_code=webhook_code,
            env_variables=env_vars,
            installation_commands=install_commands,
            setup_instructions=setup_instructions,
        )

    def _generate_backend(self, config: PaymentConfig, framework: Framework) -> str:
        """Generiere Backend Payment Code"""
        if framework == Framework.FASTAPI:
            return self._generate_fastapi_backend(config)
        elif framework == Framework.DJANGO:
            return self._generate_django_backend(config)
        elif framework == Framework.FLASK:
            return self._generate_flask_backend(config)
        elif framework == Framework.EXPRESS:
            return self._generate_express_backend(config)
        else:
            return "# Unsupported backend framework"

    def _generate_fastapi_backend(self, config: PaymentConfig) -> str:
        """Generiere FastAPI Payment Code"""
        if config.provider == PaymentProvider.STRIPE:
            return self._generate_fastapi_stripe(config)
        elif config.provider == PaymentProvider.PAYPAL:
            return self._generate_fastapi_paypal(config)
        elif config.provider == PaymentProvider.BOTH:
            return self._generate_fastapi_stripe(config) + "\n\n" + self._generate_fastapi_paypal(config)
        return ""

    def _generate_fastapi_stripe(self, config: PaymentConfig) -> str:
        """Generiere FastAPI + Stripe Code"""
        if config.pricing_model == PricingModel.SUBSCRIPTION:
            return f'''"""
Stripe Subscription Payment Integration
Auto-generated by VibeAI Payment Generator
"""

import stripe
import os
from fastapi import APIRouter, HTTPException, Request
from pydantic import BaseModel
from typing import Optional

router = APIRouter(prefix="/payments/stripe", tags=["Stripe Payments"])

# Initialize Stripe
stripe.api_key = os.getenv("STRIPE_SECRET_KEY")

class CheckoutRequest(BaseModel):
    """Checkout session request"""
    price_id: str
    customer_email: Optional[str] = None
    trial_days: int = {config.trial_days}

class PortalRequest(BaseModel):
    """Customer portal request"""
    customer_id: str

@router.post("/create-checkout-session")
async def create_checkout_session(request: CheckoutRequest):
    """
    Create Stripe Checkout Session for Subscription

    Returns:
        - checkout_url: URL to redirect customer to
        - session_id: Stripe session ID
    """
    try:
        # Create checkout session
        session = stripe.checkout.Session.create(
            mode="subscription",
            success_url="{config.success_url}?session_id={{{{CHECKOUT_SESSION_ID}}}}",
            cancel_url="{config.cancel_url}",
            customer_email=request.customer_email,
            line_items=[
                {{
                    "price": request.price_id,
                    "quantity": 1
                }}
            ],
            subscription_data={{
                "trial_period_days": request.trial_days if request.trial_days > 0 else None
            }} if request.trial_days > 0 else None,
            allow_promotion_codes=True,
            billing_address_collection="auto"
        )

        return {{
            "success": True,
            "checkout_url": session.url,
            "session_id": session.id
        }}

    except stripe.error.StripeError as e:
        raise HTTPException(status_code=400, detail=str(e))

@router.post("/create-portal-session")
async def create_portal_session(request: PortalRequest):
    """
    Create Customer Portal Session for Subscription Management

    Returns:
        - portal_url: URL to customer portal
    """
    try:
        session = stripe.billing_portal.Session.create(
            customer=request.customer_id,
            return_url="{config.success_url}"
        )

        return {{
            "success": True,
            "portal_url": session.url
        }}

    except stripe.error.StripeError as e:
        raise HTTPException(status_code=400, detail=str(e))

@router.get("/subscription/{{subscription_id}}")
async def get_subscription(subscription_id: str):
    """
    Get subscription details

    Returns:
        - status: active, canceled, past_due, etc.
        - current_period_end: Unix timestamp
        - cancel_at_period_end: boolean
    """
    try:
        subscription = stripe.Subscription.retrieve(subscription_id)

        return {{
            "success": True,
            "subscription": {{
                "id": subscription.id,
                "status": subscription.status,
                "current_period_end": subscription.current_period_end,
                "cancel_at_period_end": subscription.cancel_at_period_end,
                "customer": subscription.customer
            }}
        }}

    except stripe.error.StripeError as e:
        raise HTTPException(status_code=400, detail=str(e))

@router.post("/subscription/{{subscription_id}}/cancel")
async def cancel_subscription(subscription_id: str):
    """
    Cancel subscription at period end

    Returns:
        - success: boolean
        - cancel_at_period_end: timestamp
    """
    try:
        subscription = stripe.Subscription.modify(
            subscription_id,
            cancel_at_period_end=True
        )

        return {{
            "success": True,
            "message": "Subscription will be canceled at period end",
            "cancel_at_period_end": subscription.current_period_end
        }}

    except stripe.error.StripeError as e:
        raise HTTPException(status_code=400, detail=str(e))
'''
        else:  # ONE_TIME payment
            int(config.amount * 100) if config.amount else 1000
            return f'''"""
Stripe One-Time Payment Integration
Auto-generated by VibeAI Payment Generator
"""

import stripe
import os
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from typing import Optional, List, Dict

router = APIRouter(prefix="/payments/stripe", tags=["Stripe Payments"])

# Initialize Stripe
stripe.api_key = os.getenv("STRIPE_SECRET_KEY")

class ProductItem(BaseModel):
    """Product line item"""
    name: str
    amount: int  # in cents
    quantity: int = 1
    description: Optional[str] = None

class CheckoutRequest(BaseModel):
    """Checkout request"""
    items: List[ProductItem]
    customer_email: Optional[str] = None
    currency: str = "{config.currency}"

@router.post("/create-payment-intent")
async def create_payment_intent(request: CheckoutRequest):
    """
    Create Payment Intent for one-time payment

    Returns:
        - client_secret: For Stripe Elements
        - payment_intent_id: Payment Intent ID
    """
    try:
        # Calculate total amount
        total_amount = sum(item.amount * item.quantity for item in request.items)

        # Create payment intent
        intent = stripe.PaymentIntent.create(
            amount=total_amount,
            currency=request.currency,
            automatic_payment_methods={{"enabled": True}},
            receipt_email=request.customer_email,
            metadata={{
                "items": str([item.dict() for item in request.items])
            }}
        )

        return {{
            "success": True,
            "client_secret": intent.client_secret,
            "payment_intent_id": intent.id,
            "amount": total_amount
        }}

    except stripe.error.StripeError as e:
        raise HTTPException(status_code=400, detail=str(e))

@router.post("/create-checkout-session")
async def create_checkout_session(request: CheckoutRequest):
    """
    Create Stripe Checkout Session for one-time payment

    Returns:
        - checkout_url: URL to redirect customer to
    """
    try:
        # Convert items to line items
        line_items = [
            {{
                "price_data": {{
                    "currency": request.currency,
                    "product_data": {{
                        "name": item.name,
                        "description": item.description
                    }},
                    "unit_amount": item.amount
                }},
                "quantity": item.quantity
            }}
            for item in request.items
        ]

        session = stripe.checkout.Session.create(
            mode="payment",
            success_url="{config.success_url}?session_id={{{{CHECKOUT_SESSION_ID}}}}",
            cancel_url="{config.cancel_url}",
            customer_email=request.customer_email,
            line_items=line_items,
            allow_promotion_codes=True,
            billing_address_collection="required"
        )

        return {{
            "success": True,
            "checkout_url": session.url,
            "session_id": session.id
        }}

    except stripe.error.StripeError as e:
        raise HTTPException(status_code=400, detail=str(e))

@router.get("/payment-intent/{{payment_intent_id}}")
async def get_payment_intent(payment_intent_id: str):
    """
    Get payment intent status

    Returns:
        - status: succeeded, processing, requires_payment_method, etc.
        - amount: Amount in cents
    """
    try:
        intent = stripe.PaymentIntent.retrieve(payment_intent_id)

        return {{
            "success": True,
            "status": intent.status,
            "amount": intent.amount,
            "currency": intent.currency,
            "customer": intent.customer
        }}

    except stripe.error.StripeError as e:
        raise HTTPException(status_code=400, detail=str(e))
'''

    def _generate_fastapi_paypal(self, config: PaymentConfig) -> str:
        """Generiere FastAPI + PayPal Code"""
        return f'''"""
PayPal Payment Integration
Auto-generated by VibeAI Payment Generator
"""

import os
import requests
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from typing import Optional, List, Dict

router = APIRouter(prefix="/payments/paypal", tags=["PayPal Payments"])

# PayPal Configuration
PAYPAL_CLIENT_ID = os.getenv("PAYPAL_CLIENT_ID")
PAYPAL_CLIENT_SECRET = os.getenv("PAYPAL_CLIENT_SECRET")
PAYPAL_MODE = os.getenv("PAYPAL_MODE", "sandbox")  # sandbox or live

PAYPAL_API_BASE = (
    "https://api-m.sandbox.paypal.com" if PAYPAL_MODE == "sandbox"
    else "https://api-m.paypal.com"
)

class OrderItem(BaseModel):
    """PayPal order item"""
    name: str
    unit_amount: float
    quantity: int = 1
    description: Optional[str] = None

class CreateOrderRequest(BaseModel):
    """Create PayPal order request"""
    items: List[OrderItem]
    currency: str = "{config.currency.upper()}"

def get_paypal_access_token() -> str:
    """Get PayPal OAuth access token"""
    url = f"{{PAYPAL_API_BASE}}/v1/oauth2/token"

    response = requests.post(
        url,
        headers={{"Accept": "application/json"}},
        auth=(PAYPAL_CLIENT_ID, PAYPAL_CLIENT_SECRET),
        data={{"grant_type": "client_credentials"}}
    )

    if response.status_code == 200:
        return response.json()["access_token"]
    else:
        raise HTTPException(status_code=500, detail="Failed to get PayPal access token")

@router.post("/create-order")
async def create_order(request: CreateOrderRequest):
    """
    Create PayPal order

    Returns:
        - order_id: PayPal order ID
        - approval_url: URL for customer to approve payment
    """
    try:
        access_token = get_paypal_access_token()

        # Calculate total
        total = sum(item.unit_amount * item.quantity for item in request.items)

        # Create order payload
        order_data = {{
            "intent": "CAPTURE",
            "purchase_units": [
                {{
                    "amount": {{
                        "currency_code": request.currency,
                        "value": f"{{total:.2f}}",
                        "breakdown": {{
                            "item_total": {{
                                "currency_code": request.currency,
                                "value": f"{{total:.2f}}"
                            }}
                        }}
                    }},
                    "items": [
                        {{
                            "name": item.name,
                            "description": item.description or item.name,
                            "unit_amount": {{
                                "currency_code": request.currency,
                                "value": f"{{item.unit_amount:.2f}}"
                            }},
                            "quantity": str(item.quantity)
                        }}
                        for item in request.items
                    ]
                }}
            ],
            "application_context": {{
                "return_url": "{config.success_url}",
                "cancel_url": "{config.cancel_url}",
                "brand_name": "Your App Name",
                "user_action": "PAY_NOW"
            }}
        }}

        # Create order
        response = requests.post(
            f"{{PAYPAL_API_BASE}}/v2/checkout/orders",
            headers={{
                "Content-Type": "application/json",
                "Authorization": f"Bearer {{access_token}}"
            }},
            json=order_data
        )

        if response.status_code == 201:
            order = response.json()
            approval_url = next(
                link["href"] for link in order["links"] if link["rel"] == "approve"
            )

            return {{
                "success": True,
                "order_id": order["id"],
                "approval_url": approval_url
            }}
        else:
            raise HTTPException(status_code=400, detail=response.json())

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/capture-order/{{order_id}}")
async def capture_order(order_id: str):
    """
    Capture PayPal order after customer approval

    Returns:
        - status: COMPLETED, FAILED, etc.
        - capture_id: PayPal capture ID
    """
    try:
        access_token = get_paypal_access_token()

        response = requests.post(
            f"{{PAYPAL_API_BASE}}/v2/checkout/orders/{{order_id}}/capture",
            headers={{
                "Content-Type": "application/json",
                "Authorization": f"Bearer {{access_token}}"
            }}
        )

        if response.status_code == 201:
            capture = response.json()

            return {{
                "success": True,
                "status": capture["status"],
                "capture_id": capture["purchase_units"][0]["payments"]["captures"][0]["id"]
            }}
        else:
            raise HTTPException(status_code=400, detail=response.json())

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/order/{{order_id}}")
async def get_order(order_id: str):
    """
    Get PayPal order details

    Returns:
        - status: CREATED, APPROVED, COMPLETED, etc.
        - amount: Order amount
    """
    try:
        access_token = get_paypal_access_token()

        response = requests.get(
            f"{{PAYPAL_API_BASE}}/v2/checkout/orders/{{order_id}}",
            headers={{
                "Authorization": f"Bearer {{access_token}}"
            }}
        )

        if response.status_code == 200:
            order = response.json()

            return {{
                "success": True,
                "order_id": order["id"],
                "status": order["status"],
                "amount": order["purchase_units"][0]["amount"]["value"],
                "currency": order["purchase_units"][0]["amount"]["currency_code"]
            }}
        else:
            raise HTTPException(status_code=400, detail=response.json())

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
'''

    def _generate_webhooks(self, config: PaymentConfig, framework: Framework) -> str:
        """Generiere Webhook Handler"""
        if framework != Framework.FASTAPI:
            return "# Webhook handlers for other frameworks not yet implemented"

        webhook_code = ""

        if config.provider in [PaymentProvider.STRIPE, PaymentProvider.BOTH]:
            webhook_code += self._generate_stripe_webhook()

        if config.provider in [PaymentProvider.PAYPAL, PaymentProvider.BOTH]:
            webhook_code += "\n\n" + self._generate_paypal_webhook()

        return webhook_code

    def _generate_stripe_webhook(self) -> str:
        """Generiere Stripe Webhook Handler"""
        return '''"""
Stripe Webhook Handler
Handles: payment_intent.succeeded, customer.subscription.updated, etc.
"""

import stripe
import os
from fastapi import APIRouter, Request, HTTPException

router = APIRouter(prefix="/webhooks/stripe", tags=["Stripe Webhooks"])

STRIPE_WEBHOOK_SECRET = os.getenv("STRIPE_WEBHOOK_SECRET")

@router.post("/")
async def stripe_webhook(request: Request):
    """
    Handle Stripe webhooks

    Events handled:
    - payment_intent.succeeded
    - payment_intent.payment_failed
    - customer.subscription.created
    - customer.subscription.updated
    - customer.subscription.deleted
    - invoice.payment_succeeded
    - invoice.payment_failed
    """
    payload = await request.body()
    sig_header = request.headers.get("stripe-signature")

    try:
        event = stripe.Webhook.construct_event(
            payload, sig_header, STRIPE_WEBHOOK_SECRET
        )
    except ValueError:
        raise HTTPException(status_code=400, detail="Invalid payload")
    except stripe.error.SignatureVerificationError:
        raise HTTPException(status_code=400, detail="Invalid signature")

    # Handle the event
    event_type = event["type"]
    data = event["data"]["object"]

    if event_type == "payment_intent.succeeded":
        # Payment succeeded
        payment_intent_id = data["id"]
        amount = data["amount"]
        customer = data.get("customer")

        print(f"âœ… Payment succeeded: {payment_intent_id} for ${amount/100}")

        # TODO: Update your database
        # - Mark order as paid
        # - Send confirmation email
        # - Unlock premium features

    elif event_type == "payment_intent.payment_failed":
        # Payment failed
        payment_intent_id = data["id"]
        error_message = data.get("last_payment_error", {}).get("message")

        print(f"âŒ Payment failed: {payment_intent_id} - {error_message}")

        # TODO: Notify customer of failed payment

    elif event_type == "customer.subscription.created":
        # New subscription
        subscription_id = data["id"]
        customer = data["customer"]
        status = data["status"]

        print(f"ðŸŽ‰ New subscription: {subscription_id} - Status: {status}")

        # TODO: Update database
        # - Create subscription record
        # - Activate premium features
        # - Send welcome email

    elif event_type == "customer.subscription.updated":
        # Subscription updated
        subscription_id = data["id"]
        status = data["status"]
        cancel_at_period_end = data.get("cancel_at_period_end", False)

        print(f"ðŸ”„ Subscription updated: {subscription_id} - Status: {status}")

        if cancel_at_period_end:
            print(f"âš ï¸ Subscription will cancel at period end")
            # TODO: Send cancellation confirmation

        # TODO: Update subscription in database

    elif event_type == "customer.subscription.deleted":
        # Subscription canceled
        subscription_id = data["id"]
        customer = data["customer"]

        print(f"ðŸš« Subscription canceled: {subscription_id}")

        # TODO: Update database
        # - Deactivate premium features
        # - Send cancellation email

    elif event_type == "invoice.payment_succeeded":
        # Invoice paid
        invoice_id = data["id"]
        subscription_id = data.get("subscription")
        amount_paid = data["amount_paid"]

        print(f"ðŸ’° Invoice paid: {invoice_id} - ${amount_paid/100}")

        # TODO: Update payment history
        # - Send receipt email

    elif event_type == "invoice.payment_failed":
        # Invoice payment failed
        invoice_id = data["id"]
        subscription_id = data.get("subscription")

        print(f"âŒ Invoice payment failed: {invoice_id}")

        # TODO: Handle failed payment
        # - Send payment failed notification
        # - Update subscription status

    else:
        print(f"â„¹ï¸ Unhandled event type: {event_type}")

    return {"success": True}
'''

    def _generate_paypal_webhook(self) -> str:
        """Generiere PayPal Webhook Handler"""
        return '''"""
PayPal Webhook Handler
Handles: PAYMENT.CAPTURE.COMPLETED, BILLING.SUBSCRIPTION.ACTIVATED, etc.
"""

import os
import hmac
import hashlib
from fastapi import APIRouter, Request, HTTPException

router = APIRouter(prefix="/webhooks/paypal", tags=["PayPal Webhooks"])

PAYPAL_WEBHOOK_ID = os.getenv("PAYPAL_WEBHOOK_ID")

@router.post("/")
async def paypal_webhook(request: Request):
    """
    Handle PayPal webhooks

    Events handled:
    - PAYMENT.CAPTURE.COMPLETED
    - PAYMENT.CAPTURE.DENIED
    - CHECKOUT.ORDER.APPROVED
    - BILLING.SUBSCRIPTION.ACTIVATED
    - BILLING.SUBSCRIPTION.CANCELLED
    """
    payload = await request.json()

    # Verify webhook signature (optional but recommended)
    # Note: PayPal webhook verification is more complex
    # For production, implement full webhook verification

    event_type = payload.get("event_type")
    resource = payload.get("resource", {})

    if event_type == "PAYMENT.CAPTURE.COMPLETED":
        # Payment captured
        capture_id = resource.get("id")
        amount = resource.get("amount", {}).get("value")
        currency = resource.get("amount", {}).get("currency_code")

        print(f"âœ… Payment captured: {capture_id} for {currency} {amount}")

        # TODO: Update your database
        # - Mark order as paid
        # - Send confirmation email

    elif event_type == "PAYMENT.CAPTURE.DENIED":
        # Payment denied
        capture_id = resource.get("id")

        print(f"âŒ Payment denied: {capture_id}")

        # TODO: Handle denied payment

    elif event_type == "CHECKOUT.ORDER.APPROVED":
        # Order approved by customer
        order_id = resource.get("id")

        print(f"âœ… Order approved: {order_id}")

        # TODO: Capture the order automatically or wait for manual capture

    elif event_type == "BILLING.SUBSCRIPTION.ACTIVATED":
        # Subscription activated
        subscription_id = resource.get("id")

        print(f"ðŸŽ‰ Subscription activated: {subscription_id}")

        # TODO: Update database
        # - Create subscription record
        # - Activate premium features

    elif event_type == "BILLING.SUBSCRIPTION.CANCELLED":
        # Subscription cancelled
        subscription_id = resource.get("id")

        print(f"ðŸš« Subscription cancelled: {subscription_id}")

        # TODO: Update database
        # - Deactivate premium features

    else:
        print(f"â„¹ï¸ Unhandled event type: {event_type}")

    return {"success": True}
'''

    def _generate_frontend(self, config: PaymentConfig, framework: Framework) -> str:
        """Generiere Frontend Payment Code"""
        if framework == Framework.REACT:
            return self._generate_react_frontend(config)
        elif framework == Framework.FLUTTER:
            return self._generate_flutter_frontend(config)
        elif framework == Framework.REACT_NATIVE:
            return self._generate_react_native_frontend(config)
        else:
            return "// Unsupported frontend framework"

    def _generate_react_frontend(self, config: PaymentConfig) -> str:
        """Generiere React Payment UI"""
        if config.provider == PaymentProvider.STRIPE:
            return self._generate_react_stripe()
        elif config.provider == PaymentProvider.PAYPAL:
            return self._generate_react_paypal()
        else:
            return self._generate_react_stripe() + "\n\n" + self._generate_react_paypal()

    def _generate_react_stripe(self) -> str:
        """Generiere React Stripe Elements"""
        return """/**
 * Stripe Payment Component
 * Uses Stripe Elements for secure payment processing
 */

import React, { useState } from 'react';
import { loadStripe } from '@stripe/stripe-js';
import {
  Elements,
  CardElement,
  useStripe,
  useElements
} from '@stripe/react-stripe-js';

// Initialize Stripe
const stripePromise = loadStripe(process.env.REACT_APP_STRIPE_PUBLISHABLE_KEY);

const CheckoutForm = ({ amount, onSuccess, onError }) => {
  const stripe = useStripe();
  const elements = useElements();
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const handleSubmit = async (event) => {
    event.preventDefault();

    if (!stripe || !elements) {
      return;
    }

    setLoading(true);
    setError(null);

    try {
      // Create payment intent on backend
      const response = await fetch('/payments/stripe/create-payment-intent', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          items: [{ name: 'Premium Plan', amount: amount * 100, quantity: 1 }],
          currency: 'usd'
        })
      });

      const { client_secret } = await response.json();

      // Confirm payment
      const { error: stripeError, paymentIntent } = await stripe.confirmCardPayment(
        client_secret,
        {
          payment_method: {
            card: elements.getElement(CardElement)
          }
        }
      );

      if (stripeError) {
        setError(stripeError.message);
        onError?.(stripeError);
      } else if (paymentIntent.status === 'succeeded') {
        onSuccess?.(paymentIntent);
      }
    } catch (err) {
      setError(err.message);
      onError?.(err);
    } finally {
      setLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="stripe-form">
      <div className="card-element-wrapper">
        <CardElement
          options={{
            style: {
              base: {
                fontSize: '16px',
                color: '#424770',
                '::placeholder': {
                  color: '#aab7c4'
                }
              },
              invalid: {
                color: '#9e2146'
              }
            }
          }}
        />
      </div>

      {error && <div className="error-message">{error}</div>}

      <button
        type="submit"
        disabled={!stripe || loading}
        className="pay-button"
      >
        {loading ? 'Processing...' : `Pay $${amount}`}
      </button>
    </form>
  );
};

const StripePayment = ({ amount, onSuccess, onError }) => {
  return (
    <Elements stripe={stripePromise}>
      <CheckoutForm
        amount={amount}
        onSuccess={onSuccess}
        onError={onError}
      />
    </Elements>
  );
};

export default StripePayment;

/**
 * Stripe Checkout (Hosted Page) Component
 * Redirects to Stripe-hosted checkout page
 */

export const StripeCheckout = ({ priceId, onError }) => {
  const [loading, setLoading] = useState(false);

  const handleCheckout = async () => {
    setLoading(true);

    try {
      const response = await fetch('/payments/stripe/create-checkout-session', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          price_id: priceId,
          trial_days: 7
        })
      });

      const { checkout_url } = await response.json();
      window.location.href = checkout_url;
    } catch (err) {
      onError?.(err);
      setLoading(false);
    }
  };

  return (
    <button
      onClick={handleCheckout}
      disabled={loading}
      className="checkout-button"
    >
      {loading ? 'Loading...' : 'Subscribe Now'}
    </button>
  );
};
"""

    def _generate_react_paypal(self) -> str:
        """Generiere React PayPal Buttons"""
        return """/**
 * PayPal Payment Component
 * Uses PayPal Smart Payment Buttons
 */

import React, { useEffect, useState } from 'react';

const PayPalButton = ({ amount, currency = 'USD', onSuccess, onError }) => {
  const [sdkReady, setSdkReady] = useState(false);

  useEffect(() => {
    // Load PayPal SDK
    const script = document.createElement('script');
    script.src = `https://www.paypal.com/sdk/js?client-id=${process.env.REACT_APP_PAYPAL_CLIENT_ID}&currency=${currency}`;
    script.addEventListener('load', () => setSdkReady(true));
    document.body.appendChild(script);

    return () => {
      document.body.removeChild(script);
    };
  }, [currency]);

  useEffect(() => {
    if (!sdkReady) return;

    window.paypal.Buttons({
      createOrder: async (data, actions) => {
        try {
          // Create order on backend
          const response = await fetch('/payments/paypal/create-order', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              items: [
                {
                  name: 'Premium Plan',
                  unit_amount: amount,
                  quantity: 1
                }
              ],
              currency: currency
            })
          });

          const { order_id } = await response.json();
          return order_id;
        } catch (err) {
          onError?.(err);
          throw err;
        }
      },
      onApprove: async (data, actions) => {
        try {
          // Capture order on backend
          const response = await fetch(
            `/payments/paypal/capture-order/${data.orderID}`,
            { method: 'POST' }
          );

          const details = await response.json();
          onSuccess?.(details);
        } catch (err) {
          onError?.(err);
        }
      },
      onError: (err) => {
        onError?.(err);
      }
    }).render('#paypal-button-container');
  }, [sdkReady, amount, currency, onSuccess, onError]);

  if (!sdkReady) {
    return <div>Loading PayPal...</div>;
  }

  return <div id="paypal-button-container"></div>;
};

export default PayPalButton;
"""

    def _generate_flutter_frontend(self, config: PaymentConfig) -> str:
        """Generiere Flutter Payment UI"""
        return """/**
 * Flutter Stripe Payment Sheet
 * Uses flutter_stripe package
 */

import 'package:flutter/material.dart';
import 'package:flutter_stripe/flutter_stripe.dart';
import 'package:http/http.dart' as http;
import 'dart:convert';

class StripePaymentScreen extends StatefulWidget {
  @override
  _StripePaymentScreenState createState() => _StripePaymentScreenState();
}

class _StripePaymentScreenState extends State<StripePaymentScreen> {
  bool _loading = false;

  Future<void> _handlePayment() async {
    setState(() => _loading = true);

    try {
      // Create payment intent
      final response = await http.post(
        Uri.parse('YOUR_API_URL/payments/stripe/create-payment-intent'),
        headers: {'Content-Type': 'application/json'},
        body: jsonEncode({
          'items': [
            {'name': 'Premium Plan', 'amount': 1999, 'quantity': 1}
          ],
          'currency': 'usd'
        }),
      );

      final data = jsonDecode(response.body);
      final clientSecret = data['client_secret'];

      // Initialize payment sheet
      await Stripe.instance.initPaymentSheet(
        paymentSheetParameters: SetupPaymentSheetParameters(
          merchantDisplayName: 'Your App Name',
          paymentIntentClientSecret: clientSecret,
          style: ThemeMode.system,
        ),
      );

      // Present payment sheet
      await Stripe.instance.presentPaymentSheet();

      // Payment successful
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Payment successful!')),
      );
    } catch (e) {
      // Payment failed or canceled
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Payment failed: $e')),
      );
    } finally {
      setState(() => _loading = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Premium Upgrade')),
      body: Center(
        child: _loading
            ? CircularProgressIndicator()
            : ElevatedButton(
                onPressed: _handlePayment,
                child: Text('Pay $19.99'),
              ),
      ),
    );
  }
}
"""

    def _generate_env_variables(self, config: PaymentConfig) -> Dict[str, str]:
        """Generiere Environment Variables"""
        env_vars = {}

        if config.provider in [PaymentProvider.STRIPE, PaymentProvider.BOTH]:
            env_vars.update(
                {
                    "STRIPE_SECRET_KEY": "sk_test_...",
                    "STRIPE_PUBLISHABLE_KEY": "pk_test_...",
                    "STRIPE_WEBHOOK_SECRET": "whsec_...",
                }
            )

        if config.provider in [PaymentProvider.PAYPAL, PaymentProvider.BOTH]:
            env_vars.update(
                {
                    "PAYPAL_CLIENT_ID": "YOUR_CLIENT_ID",
                    "PAYPAL_CLIENT_SECRET": "YOUR_CLIENT_SECRET",
                    "PAYPAL_MODE": "sandbox",
                    "PAYPAL_WEBHOOK_ID": "YOUR_WEBHOOK_ID",
                }
            )

        return env_vars

    def _generate_install_commands(
        self,
        config: PaymentConfig,
        backend_framework: Framework,
        frontend_framework: Optional[Framework],
    ) -> List[str]:
        """Generiere Installation Commands"""
        commands = []

        # Backend dependencies
        if backend_framework == Framework.FASTAPI:
            if config.provider in [PaymentProvider.STRIPE, PaymentProvider.BOTH]:
                commands.append("pip install stripe")
            if config.provider in [PaymentProvider.PAYPAL, PaymentProvider.BOTH]:
                commands.append("pip install requests")

        # Frontend dependencies
        if frontend_framework == Framework.REACT:
            if config.provider in [PaymentProvider.STRIPE, PaymentProvider.BOTH]:
                commands.append("npm install @stripe/stripe-js @stripe/react-stripe-js")

        elif frontend_framework == Framework.FLUTTER:
            if config.provider in [PaymentProvider.STRIPE, PaymentProvider.BOTH]:
                commands.append("flutter pub add flutter_stripe")
                commands.append("flutter pub add http")

        return commands

    def _generate_setup_instructions(self, config: PaymentConfig) -> str:
        """Generiere Setup Instructions"""
        instructions = "# Payment System Setup Instructions\n\n"

        if config.provider in [PaymentProvider.STRIPE, PaymentProvider.BOTH]:
            instructions += """## Stripe Setup

1. Create Stripe account at https://stripe.com
2. Get API keys from Dashboard â†’ Developers â†’ API keys
3. Add keys to .env file:
   ```
   STRIPE_SECRET_KEY=sk_test_...
   STRIPE_PUBLISHABLE_KEY=pk_test_...
   ```
4. Create webhook endpoint:
   - Dashboard â†’ Developers â†’ Webhooks
   - Add endpoint: https://yourapp.com/webhooks/stripe
   - Select events: payment_intent.*, customer.subscription.*
   - Copy webhook secret to .env

5. Create products/prices:
   - Dashboard â†’ Products
   - Create product with price
   - Copy price ID (price_...)

"""

        if config.provider in [PaymentProvider.PAYPAL, PaymentProvider.BOTH]:
            instructions += """## PayPal Setup

1. Create PayPal Developer account at https://developer.paypal.com
2. Create App in Dashboard
3. Get Client ID and Secret
4. Add to .env file:
   ```
   PAYPAL_CLIENT_ID=YOUR_CLIENT_ID
   PAYPAL_CLIENT_SECRET=YOUR_CLIENT_SECRET
   PAYPAL_MODE=sandbox
   ```
5. Create webhook:
   - Apps & Credentials â†’ Your App â†’ Webhooks
   - Add webhook URL: https://yourapp.com/webhooks/paypal
   - Subscribe to events: PAYMENT.*, BILLING.SUBSCRIPTION.*

"""

        instructions += """## Testing

### Stripe Test Cards
- Success: 4242 4242 4242 4242
- Declined: 4000 0000 0000 0002
- Requires authentication: 4000 0025 0000 3155

### PayPal Sandbox
- Use sandbox.paypal.com test accounts
- Create buyer/seller accounts in Developer Dashboard

## Production Checklist
- [ ] Replace test keys with live keys
- [ ] Set PAYPAL_MODE=live
- [ ] Verify webhook endpoints are accessible
- [ ] Test payment flow end-to-end
- [ ] Implement proper error handling
- [ ] Add logging and monitoring
- [ ] Review Stripe/PayPal compliance requirements
"""

        return instructions

    # Helper methods for other frameworks
    def _generate_django_backend(self, config: PaymentConfig) -> str:
        return "# Django payment integration - coming soon"

    def _generate_flask_backend(self, config: PaymentConfig) -> str:
        return "# Flask payment integration - coming soon"

    def _generate_express_backend(self, config: PaymentConfig) -> str:
        return "# Express payment integration - coming soon"

    def _generate_react_native_frontend(self, config: PaymentConfig) -> str:
        return "// React Native payment integration - coming soon"

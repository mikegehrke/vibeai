from datetime import datetime

from pydantic import BaseModel


class BillingRecord(BaseModel):
    user_id: str
    model: str
    tokens_used: int
    cost_usd: float
    timestamp: datetime = datetime.utcnow()


class Subscription(BaseModel):
    user_id: str
    tier: str
    renewal_date: datetime


class ReferralBonus(BaseModel):
    user_id: str
    referred_user_id: str
    bonus_tokens: int
    timestamp: datetime = datetime.utcnow()


# -------------------------------------------------------------
# VIBEAI – BILLING DATABASE MODELS (SQL & Pydantic)
# -------------------------------------------------------------
from sqlalchemy import Boolean, Column, DateTime, Float, Integer, String
from sqlalchemy.orm import declarative_base

Base = declarative_base()


class BillingRecordDB(Base):
    """
    Datenbank-Modell für Billing Records.
    Speichert jeden AI-API-Call mit Kosten und Token-Verbrauch.
    """

    __tablename__ = "billing_records"

    id = Column(String, primary_key=True)
    user_id = Column(String, index=True)
    model = Column(String)  # GPT / Claude / Gemini / Copilot / Ollama
    provider = Column(String)  # openai / anthropic / google / github / local
    tokens_used = Column(Integer)
    cost_usd = Column(Float)
    created_at = Column(DateTime, default=datetime.utcnow)


class SubscriptionDB(Base):
    """
    Datenbank-Modell für Subscriptions.
    Verwaltet User-Tier (Free/Pro/Ultra/Enterprise).
    """

    __tablename__ = "subscriptions"

    id = Column(String, primary_key=True)
    user_id = Column(String, index=True)
    tier = Column(String)  # free / pro / ultra / enterprise
    is_active = Column(Boolean, default=True)
    auto_renew = Column(Boolean, default=True)
    renewal_date = Column(DateTime)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)


class ReferralBonusDB(Base):
    """
    Datenbank-Modell für Referral Bonuses.
    Tracked wer wen eingeladen hat und welche Boni vergeben wurden.
    """

    __tablename__ = "referral_bonus"

    id = Column(String, primary_key=True)
    user_id = Column(String, index=True)
    referred_user_id = Column(String)
    bonus_tokens = Column(Integer)
    status = Column(String, default="pending")  # pending / applied / expired
    created_at = Column(DateTime, default=datetime.utcnow)
    applied_at = Column(DateTime, nullable=True)


# -------------------------------------------------------------
# Pydantic Response Models für API
# -------------------------------------------------------------


class BillingRecordResponse(BaseModel):
    """API Response für Billing Records"""

    id: str
    user_id: str
    model: str
    provider: str
    tokens_used: int
    cost_usd: float
    created_at: datetime

    class Config:
        from_attributes = True


class SubscriptionResponse(BaseModel):
    """API Response für Subscriptions"""

    id: str
    user_id: str
    tier: str
    is_active: bool
    auto_renew: bool
    renewal_date: datetime
    created_at: datetime

    class Config:
        from_attributes = True


class ReferralBonusResponse(BaseModel):
    """API Response für Referral Bonuses"""

    id: str
    user_id: str
    referred_user_id: str
    bonus_tokens: int
    status: str
    created_at: datetime

    class Config:
        from_attributes = True


# ============================================================
# ⭐ VIBEAI – ADVANCED BILLING MODELS (2025)
# ============================================================
# ✔ Usage Tracking (per Provider/Model/Feature)
# ✔ Payment Transactions (Stripe/PayPal)
# ✔ Credits & Balance System
# ✔ Feature Usage Limits (Chat/Builder/Studio)
# ✔ Audit Logs
# ✔ Invoice Generation
# ============================================================


class UsageRecordDB(Base):
    """
    Detailliertes Usage Tracking pro Feature.
    Tracks: Chat, Builder, Code Studio, App Studio, etc.
    """

    __tablename__ = "usage_records"

    id = Column(String, primary_key=True)
    user_id = Column(String, index=True)
    feature = Column(String)  # chat / builder / studio / code
    operation = Column(String)  # generate / build / compile / chat
    provider = Column(String)  # openai / anthropic / google / github
    model = Column(String)  # gpt-5 / claude-3.5 / gemini-2.0
    input_tokens = Column(Integer, default=0)
    output_tokens = Column(Integer, default=0)
    total_tokens = Column(Integer, default=0)
    cost_usd = Column(Float, default=0.0)
    latency_ms = Column(Integer, default=0)
    success = Column(Boolean, default=True)
    error_message = Column(String, nullable=True)
    metadata = Column(String, nullable=True)  # JSON string for extra data
    created_at = Column(DateTime, default=datetime.utcnow)


class PaymentTransactionDB(Base):
    """
    Payment Transaction History (Stripe, PayPal, etc.).
    """

    __tablename__ = "payment_transactions"

    id = Column(String, primary_key=True)
    user_id = Column(String, index=True)
    provider = Column(String)  # stripe / paypal / crypto
    transaction_id = Column(String, unique=True)
    amount = Column(Float)
    currency = Column(String, default="USD")
    status = Column(String)  # pending / success / failed / refunded
    payment_method = Column(String)  # card / paypal / bank
    invoice_id = Column(String, nullable=True)
    description = Column(String, nullable=True)
    metadata = Column(String, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)


class UserCreditsDB(Base):
    """
    User Credit Balance System.
    Credits können gekauft, verdient (Referral) oder gewonnen werden.
    """

    __tablename__ = "user_credits"

    id = Column(String, primary_key=True)
    user_id = Column(String, unique=True, index=True)
    credits = Column(Float, default=0.0)
    bonus_credits = Column(Float, default=0.0)  # From referrals, promotions
    lifetime_credits = Column(Float, default=0.0)
    last_purchase_date = Column(DateTime, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)


class FeatureUsageLimitDB(Base):
    """
    Feature-specific Usage Limits (pro Tag/Monat).
    Z.B. Builder: max 50 projects/day, Code Studio: max 1000 ops/day
    """

    __tablename__ = "feature_usage_limits"

    id = Column(String, primary_key=True)
    user_id = Column(String, index=True)
    feature = Column(String)  # chat / builder / studio / code
    daily_limit = Column(Integer)
    daily_used = Column(Integer, default=0)
    monthly_limit = Column(Integer)
    monthly_used = Column(Integer, default=0)
    last_reset_daily = Column(DateTime, default=datetime.utcnow)
    last_reset_monthly = Column(DateTime, default=datetime.utcnow)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)


class BillingAuditLogDB(Base):
    """
    Audit Log für alle Billing-Events.
    WICHTIG für Compliance, Debugging, Fraud Detection.
    """

    __tablename__ = "billing_audit_log"

    id = Column(String, primary_key=True)
    user_id = Column(String, index=True)
    event_type = Column(String)  # charge / refund / upgrade / downgrade
    event_data = Column(String)  # JSON string
    ip_address = Column(String, nullable=True)
    user_agent = Column(String, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)


class InvoiceDB(Base):
    """
    Invoice Generation für Pro/Ultra Users.
    """

    __tablename__ = "invoices"

    id = Column(String, primary_key=True)
    user_id = Column(String, index=True)
    invoice_number = Column(String, unique=True)
    period_start = Column(DateTime)
    period_end = Column(DateTime)
    subtotal = Column(Float)
    tax = Column(Float, default=0.0)
    total = Column(Float)
    currency = Column(String, default="USD")
    status = Column(String)  # draft / sent / paid / overdue
    pdf_url = Column(String, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    paid_at = Column(DateTime, nullable=True)


# ============================================================
# PYDANTIC RESPONSE MODELS (Extended)
# ============================================================


class UsageRecordResponse(BaseModel):
    """API Response für Usage Records"""

    id: str
    user_id: str
    feature: str
    operation: str
    provider: str
    model: str
    input_tokens: int
    output_tokens: int
    total_tokens: int
    cost_usd: float
    latency_ms: int
    success: bool
    created_at: datetime

    class Config:
        from_attributes = True


class PaymentTransactionResponse(BaseModel):
    """API Response für Payment Transactions"""

    id: str
    user_id: str
    provider: str
    transaction_id: str
    amount: float
    currency: str
    status: str
    created_at: datetime

    class Config:
        from_attributes = True


class UserCreditsResponse(BaseModel):
    """API Response für User Credits"""

    user_id: str
    credits: float
    bonus_credits: float
    lifetime_credits: float

    class Config:
        from_attributes = True


class InvoiceResponse(BaseModel):
    """API Response für Invoices"""

    id: str
    user_id: str
    invoice_number: str
    period_start: datetime
    period_end: datetime
    subtotal: float
    tax: float
    total: float
    status: str
    created_at: datetime

    class Config:
        from_attributes = True


# ============================================================
# HELPER FUNCTIONS
# ============================================================


def calculate_token_cost(provider: str, model: str, input_tokens: int, output_tokens: int) -> float:
    """
    Berechnet Kosten basierend auf Provider/Model.
    Beispiel-Preise (echte Preise in pricing_rules.py).
    """
    pricing = {
        "openai": {
            "gpt-5": {"input": 0.00003, "output": 0.00006},
            "gpt-4o": {"input": 0.000005, "output": 0.000015},
            "gpt-4o-mini": {"input": 0.00000015, "output": 0.0000006},
        },
        "anthropic": {
            "claude-3.5-sonnet": {"input": 0.000003, "output": 0.000015},
            "claude-3-haiku": {"input": 0.00000025, "output": 0.00000125},
        },
        "google": {
            "gemini-2.0-flash": {"input": 0.0, "output": 0.0},  # FREE
        },
        "github": {
            "gpt-4o": {"input": 0.0, "output": 0.0},  # FREE
        },
        "ollama": {
            "default": {"input": 0.0, "output": 0.0},  # FREE (local)
        },
    }

    provider_pricing = pricing.get(provider, {})
    model_pricing = provider_pricing.get(model, {"input": 0.0, "output": 0.0})

    cost = input_tokens * model_pricing["input"] + output_tokens * model_pricing["output"]

    return round(cost, 6)


def get_tier_limits(tier: str) -> dict:
    """
    Gibt Limits für einen Tier zurück.
    Sync mit limiter.py TIER_LIMITS.
    """
    limits = {
        "free": {
            "daily_requests": 20,
            "monthly_tokens": 20000,
            "builder_projects": 3,
            "code_operations": 50,
        },
        "pro": {
            "daily_requests": 200,
            "monthly_tokens": 500000,
            "builder_projects": 50,
            "code_operations": 1000,
        },
        "ultra": {
            "daily_requests": 2000,
            "monthly_tokens": 5000000,
            "builder_projects": 500,
            "code_operations": 10000,
        },
        "enterprise": {
            "daily_requests": 99999,
            "monthly_tokens": 99999999,
            "builder_projects": 99999,
            "code_operations": 99999,
        },
    }

    return limits.get(tier, limits["free"])
